"What is essential for all Computer Scientist." Some times are included because they are necessary for multiple specialization.
 1.Discrete Math. (Number theory, set theory, graph theory, probability, combinatorics). This is essential math for all programming.
2.Algorithms and data structures. Data structures and algorithms are two sides of the same coin. Algorithms and Data Structures are an essential study for all programming.
3.Automata Theory. This seem to an esoteric study. But my experience is that understanding and using state machines in programming is an effort multiplier. But few programmers take advanced of "state machine programming." State machine is a bases for software architecture.
4.The Programming Languages Course. This exposes you to the 1. The power and limitations of high level programming languages, 2. What are the current "languages of the day", and 3. The runtime data structures intrinsic to that programming language. The upper bound in performance of computer languages, is the run time data structures and algorithms.
5.The Networking course. This course did not exist when I was in college. Today it is essential in programming. The math necessary to master networking is queuing theory. No one question in its inclusion.
6.The database course. This another one that got no comment. Database is based on set theory, algorithms and data structures, and automata theory. The math in database is covered in Discrete Math.
7.Linear Algebra. This is a foundational math for: 1. Computer Graphics, 2. Computation Physics (and GPU programming), 3. Machine Learning, 4. Kalman Filters (used in GPS, inertial navigation (think rockets), and 5. target tracking (think radar and smart weapons)), 6. Orbital mechanics, 6-DOF (degrees of freedom) simulation, 7. solving differential equations, and 8. Statistics . Sometimes it is folded into Discrete Math, but mastery of Linear Algebra is a foundation for the above list.
8.Experimental Psychology. Most people worry about "computer performance". This is measuring and programming for "human performance." There is a big mismatch between computer computation and human computation. This explores how to measure if our user interface and UX (User Experience) is working correctly. We can design better UX by understanding the power and limits of human computation and perception. (How fast do people compute? What is size of short term memory? What is the decay time for short term memory? How to "keep alive" recently displayed information? What is minimum time to perceive an informational landscape? How deep should undo/redo be?)

Items left out:
 1.Operating Systems: Today's programming is far removed from the operating system. Applications live on top of an API. That API is typically several layers above the actual operating system, aka kernel. Take for example Sockets. It is an API that is (some what) portable among different OS and programming languages. Java is such the JVM isolates the programmer from which kind of OS the program is running on. Even the C, a low level language, has a run time library that isolates the programmer from the OS details. Operating Systems are now a specialization niche. Also there are far fewer operating systems now than when I was in college in the 70's.
2.Linguistics: It was thinking that this was a foundation understanding. I didn't realize most people just use libraries to create or accept speech.
3.Computer Graphics: This is a specialization area. Most people don't dive into this. Yet linear algebra is needed for this study.
4.AI. Another specialization area.
5.Specific Computer Langagues. The "language of the day" is covered in "Programming Languages." You need to know how learn new programming languages. For what you program tomorrow may have not been invented, yet. That was true for me.
6.Object Oriented Programming: This only one Programming paradigms. The computer hardware is imperative aka procedural. It is a layer of software that implements specific paradigms such as: O-O (like Smalltalk, C++, etc..), Functional programming (like LISP), and Logical programming (SQL and Prolog). This is covered in the "Programming Languages" course.

Take a look at the ACM Computer Science curriculum.
 